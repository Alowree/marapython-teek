---
date: 2025-07-08 08:32:31
title: 精通 Windows mklink
permalink: /pages/4165d4
categories:
  - Tool
  - CLI
---

# 精通 Windows `mklink`：符号链接、硬链接和目录联接

在 Windows 系统中，文件和文件夹的管理远不止复制和粘贴。NTFS 文件系统提供了一套强大的工具，称为“链接”，允许你创建高级快捷方式和目录指针，而无需重复存储数据。这不仅能帮你更好地组织文件、节省磁盘空间，还能极大地简化开发和工作流程。

本文将以 `mklink` 命令为核心，深入探讨其三种链接方式：符号链接（Symbolic Links）、硬链接（Hard Links）和目录联接（Junctions）。

<!-- more -->

注意在不同的终端环境内，对应的命令是不一样的：

- Windows cmd: `mklink Link Target`
- Windows PowerShell: `New-Item -Path link-path -Target target-path `
- Windows Zsh: `ln`
- macOS Zsh: `ln`

```cmd
C:\Users\Lenovo>mklink
创建符号链接。

MKLINK [[/D] | [/H] | [/J]] Link Target

        /D      创建目录符号链接。默认为文件符号链接。
        /H      创建硬链接而非符号链接。
        /J      创建目录联接。
        Link    指定新的符号链接名称。相当于指针或传送门，事先不存在。
        Target  指定新链接引用的路径。相当于源头文件，事先已经存在。
```

## 符号链接

符号链接（Symlink）是最通用和最强大的链接类型。它像一个高级快捷方式，是指向另一文件或目录的指针型文件。当你访问这个符号链接时，操作系统会自动将你重定向到源头文件。

创建符号链接通常需要管理员权限。

### 文件符号链接

#### 场景一：集中管理配置文件

假设你希望在所有项目中都使用位于用户目录下的同一个 `.gitconfig` 文件，以保持 Git 配置的一致性。

- 源头文件：`C:\Users\YourUser\.gitconfig`
- 链接位置：`D:\Work\ProjectA\.gitconfig`

Command Prompt

语法：`mklink link_file source_file`

- 这是 `mklink` 的默认模式，用于为单个文件创建链接

```cmd
mklink D:\Work\ProjectA\.gitconfig C:\Users\YourUser\.gitconfig
```

PowerShell

```powershell
New-Item -ItemType SymbolicLink -Path "D:\Work\ProjectA\.gitconfig" -Target "C:\Users\YourUser\.gitconfig"
```

Zsh

语法：`ln -s source_file link_file`

- `-s` 创建符号链接

```zsh
# 注意 Zsh (Git Bash) 中的路径格式和参数顺序
ln -s /c/Users/YourUser/.gitconfig /d/Work/ProjectA/.gitconfig
```

现在，在 `ProjectA` 中执行的 Git 命令会读取 `C:` 盘的全局配置，实现了配置的统一管理。

#### 场景二：在不同位置运行同一个脚本

你编写了一个常用的脚本（例如 `build.bat`），并将其保存在一个中央位置（如 `D:\Scripts`）。你希望在多个项目的根目录中都能直接调用这个脚本，而无需复制多份。

- 目标文件：`D:\Scripts\build.bat`
- 链接位置：`C:\Projects\ProjectA\build.bat`

Command Prompt

```cmd
mklink C:\Projects\ProjectA\build.bat D:\Scripts\build.bat
```

PowerShell

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Projects\ProjectA\build.bat" -Target "D:\Scripts\build.bat"
```

Zsh

```zsh
ln -s /d/Scripts/build.bat /c/Projects/ProjectA/build.bat
```

这样，你只需要维护 `D:\Scripts\build.bat` 这一个文件。在 `ProjectA` 目录中运行 `build.bat`，实际上就是在执行中央脚本，确保了所有项目使用的都是最新版本。

#### 场景三：在不同位置编辑同一个文档

你在 Neovim 的配置文件夹内创建了一份 README 文档，用以记录当前配置的功能特点。同时，你又想在自己的博客（基于 VitePress）上，对自己的 Neovim 配置进行记录和传播。为保持博客内容的及时更新，又无须同时维护两份文档，可以在博客目录中创建一个符号链接（指针文件），使其指向 Neovim 配置文件夹中的 README 文档。

Zsh

```zsh
ln -s ~/.config/nvim/README.md ~/Teek/docs/03.Editor/09.Neovim/06.nvim-config.md
```

经过测试，这个设想无法实现，因为在本地运行服务时，会产生 VitePress 开发服务器的 404 错误。

问：为什么在使用符号链接后，在博客目录内运行 `pnpm run docs:dev` 命令，VitePress 可以为源头文件成功生成和添加 frontmatter，但在浏览器中访问页面时却出现 404 错误？

答：这是因为构建工具（VitePress/Vite）和开发服务器的工作方式不同。

1. 构建时可识别：当你运行构建或开发命令时，Node.js 进程能够识别并跟随符号链接，找到并处理原始文件（例如，为其添加 frontmatter）。
2. 服务器不跟随：但是，出于安全考虑，Vite 开发服务器默认不会跟随指向项目根目录之外的符号链接。当浏览器请求这个链接文件时，服务器无法（或不允许）访问链接指向的真实文件，因此返回 404 "Not Found" 错误。

问：如何解决这个问题？

答：最简单有效的办法是改用**硬链接（Hard Link）**。硬链接直接指向文件在磁盘上的数据，对于应用程序来说，它看起来就像一个真实、独立的文件。这样，开发服务器就能正常找到并提供文件内容。

问：如何创建硬链接？

答：命令与创建符号链接类似，只需去掉 `-s` 参数即可。首先删除旧的符号链接，然后运行：

```zsh
# 注意：创建硬链接时没有 -s 参数
ln ~/.config/nvim/README.md ~/Teek/docs/03.Editor/09.Neovim/06.nvim-config.md
```

由于硬链接要求源文件和链接文件必须在同一个磁盘分区上，而这个场景（用户目录下的两个文件夹）通常满足该条件，因此这是理想的解决方案。

::: details 符号链接和源头文件的名称不同吗？

当然可以。`mklink` 命令的 `Link` 和 `Target` 参数是完全独立的。`Link` 指定的是你想要创建的链接的完整路径（包含新文件名），而 `Target` 是现有源文件的完整路径。这为你提供了更大的灵活性。

:::

#### 场景四：为脚本创建更简洁的别名

假设你的中央脚本有一个很长或不方便记忆的名称，比如 `D:\Shared\Scripts\execute-data-processing-v2.bat`。你可以在项目目录中为其创建一个更短、更易于调用的名称。

- 目标文件：`D:\Shared\Scripts\execute-data-processing-v2.bat`
- 链接位置和名称：`C:\Projects\DataAnalysis\run.bat`

Command Prompt

```cmd
mklink C:\Projects\DataAnalysis\run.bat D:\Shared\Scripts\execute-data-processing-v2.bat
```

PowerShell

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Projects\DataAnalysis\run.bat" -Target "D:\Shared\Scripts\execute-data-processing-v2.bat"
```

Zsh

```zsh
ln -s /d/Shared/Scripts/execute-data-processing-v2.bat /c/Projects/DataAnalysis/run.bat
```

现在，你只需在 `DataAnalysis` 目录中运行 `run.bat`，就可以执行那个名称很长的脚本，大大提高了便利性。

::: details Git 如何处理符号链接？

问：如果目标文件和符号链接本身都由 Git 跟踪，当目标文件的内容被修改时，Git 会检测到链接文件的变化吗？

答：不会。这是一个非常关键且容易混淆的点。Git 对待符号链接有其特殊的方式：

1. Git 跟踪的是“路径”，而非“内容”：当你在 Git 仓库中创建一个符号链接时，Git 并不关心目标文件的内容。它只记录这个链接是一个“符号链接”以及它指向的路径（例如 `../scripts/my-script.js`）。
2. 目标内容更新，链接本身不变：如果你修改了目标文件的 _内容_，符号链接文件本身没有发生任何变化——它仍然指向同一个路径。因此，运行 `git status` 时，你会看到目标文件有待提交的更改，但符号链接文件不会显示任何变化。
3. 必须直接提交目标文件：这意味着，如果你希望将目标文件的更新纳入版本控制，你必须 `git add` 并 `commit` 目标文件本身，而不是链接。

这个特性使得符号链接在 Git 仓库中非常有用，因为它允许你在不复制文件的情况下，在仓库的不同位置引用同一个文件，同时版本历史也只由目标文件自身维护。

问：那么，当目标文件在它自己的 Git 仓库中被更新并提交后，链接文件仓库中的链接会自动“更新”吗？这是否意味着链接文件仓库永远不会跟踪目标内容的变更？

答：您的理解完全正确。这正是符号链接在版本控制中的核心工作模式。

- 链接文件是“只读”的引用：从 Git 的角度来看，链接文件仓库中的符号链接只是一个静态的指针。当目标文件的内容在别处（例如，在它自己的 Git 仓库中）被更新时，链接文件本身（那个指针）没有变化，因此在链接文件仓库中运行 `git status` 不会显示任何更改。
- 更新是自动且透明的，但与 Git 无关：当你 `git pull` 更新了目标文件后，任何通过符号链接访问该文件的操作都会立即读取到最新的内容。这种“更新”是由操作系统在访问时实时完成的，而不是由 Git 在链接文件仓库中执行的。
- 内容历史完全分离：最终结果是，链接文件所在的仓库永远不会跟踪目标文件的内容历史。它只跟踪链接本身是否存在，以及它指向的路径是否发生了变化。所有内容的版本历史都由目标文件所在的仓库独立管理。

这种关注点分离的模式非常强大。它允许一个项目（链接仓库）“借用”另一个项目（目标仓库）的文件，而无需复制文件内容或其复杂的版本历史。

:::

### 目录符号链接 (`mklink /d Link Target`)

使用 `/d` 参数可以为整个目录创建链接。这是符号链接最强大的功能之一，因为它支持跨卷（从 `C:` 到 `D:`）甚至指向网络共享路径。

#### 场景一：将网络驱动器映射为本地文件夹

某些旧版软件或开发工具可能无法很好地处理网络路径 (`\\Server\Share`)。你可以创建一个目录符号链接，让网络资源看起来就像在本地一样。

- 目标网络路径：`\\NAS-Server\VideoAssets\ProjectX`
- 链接位置：`C:\Projects\Current\Assets`

Command Prompt

```cmd
mklink /d C:\Projects\Current\Assets \\NAS-Server\VideoAssets\ProjectX
```

PowerShell

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Projects\Current\Assets" -Target "\\NAS-Server\VideoAssets\ProjectX"
```

Zsh

```zsh
# Zsh/Bash 中，网络路径通常需要用双斜杠开头
ln -s //NAS-Server/VideoAssets/ProjectX /c/Projects/Current/Assets
```

现在，你可以通过 `C:\Projects\Current\Assets` 访问服务器上的文件，解决了兼容性问题。

#### 场景二：简化复杂的开发环境

在一个大型项目中，你可能需要引用一个位于文件系统深处的共享库。通过符号链接，可以将其“拉”到你的项目根目录，方便访问。

- 目标共享库：`D:\Libs\Common\Core-UI-Components`
- 链接位置：`D:\Development\WebApp\src\components`

Command Prompt

```cmd
mklink /d D:\Development\WebApp\src\components D:\Libs\Common\Core-UI-Components
```

PowerShell

```powershell
New-Item -ItemType SymbolicLink -Path "D:\Development\WebApp\src\components" -Target "D:\Libs\Common\Core-UI-Components"
```

Zsh

```zsh
ln -s /d/Libs/Common/Core-UI-Components /d/Development/WebApp/src/components
```

这使得项目结构更清晰，且所有引用此库的项目都能自动获得更新。

#### 场景三：创建 OneDrive 内的目录符号链接，使其指向本地 D 盘的文件夹

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Users\Lenovo\OneDrive\python_work" -Target "D:\python_work"
New-Item -ItemType SymbolicLink -Path "C:\Users\Lenovo\OneDrive\50.MarketingCommunications" -Target "D:\50.MarketingCommunications"
```

这样配置之后，可以使用 OneDrive 跨 macOS 和 Windows 平台即时同步文件。原来位于 Windows 系统 D 盘上的数据文件，可以逐步地同步到 macOS 上面；同样的，后期在 macOS 上更新之后的数据文件也可经过 OneDrive 再同步回 Windows 系统的 D 盘。

#### 场景四：创建 Neovim 在 Windows 默认配置文件夹内的目录符号链接，使其指向一个支持跨平台的配置目录

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Users\Lenovo\AppData\Local\nvim-josean" -Target "C:\Users\Lenovo\.config\nvim-josean"
```

## 硬链接

硬链接 (`/h`) 是指向磁盘上完全相同数据块的多个文件入口。它不像快捷方式，而是为同一个文件起了多个名字。所有硬链接地位平等，没有“原始”文件和“快捷方式”之分。只有当指向文件数据的最后一个硬链接被删除时，数据才会被真正删除。

核心限制：

- 只能用于文件，不能用于目录。
- 必须在同一卷上 （例如，链接和目标都必须在 `C:` 盘）。

#### 场景：在不同项目中共享同一个大文件

假设两个项目需要使用同一个大型资源文件（如模型、数据集或日志文件），但你不想占用双倍的磁盘空间。

- 原始文件：`C:\Projects\ProjectA\data\large_asset.dat`
- 链接位置：`C:\Projects\ProjectB\assets\shared_asset.dat`

Command Prompt

```cmd
mklink /h C:\Projects\ProjectB\assets\shared_asset.dat C:\Projects\ProjectA\data\large_asset.dat
```

PowerShell

```powershell
New-Item -ItemType HardLink -Path "C:\Projects\ProjectB\assets\shared_asset.dat" -Target "C:\Projects\ProjectA\data\large_asset.dat"
```

Zsh

```zsh
# 创建硬链接时，不使用 -s 参数
ln /c/Projects/ProjectA/data/large_asset.dat /c/Projects/ProjectB/assets/shared_asset.dat
```

现在，`ProjectA` 和 `ProjectB` 共享同一个文件数据。在一个地方修改文件，另一个地方会立即看到变化，且总共只占用一份磁盘空间。

## 目录联接

目录联接 (`/j`) 是一种专门用于重定向目录的旧版链接。它在功能上与目录符号链接非常相似，但兼容性更好，因为它的工作方式对许多应用程序是完全透明的。

核心限制：

- 只能用于目录
- 只能指向本地卷上的目录，不支持网络路径

- `mklink /J "%UserProfile%\OneDrive\Fonts" "D:\Fonts"`
  为 C:\Users\Lenovo\OneDrive\Fonts <<===>> D:\Fonts 创建的联接

- `mklink /J "%UserProfile%\OneDrive\Ebooks" "D:\Ebooks"`
  为 C:\Users\Lenovo\OneDrive\Ebooks <<===>> D:\Ebooks 创建的联接

#### 场景：将应用程序数据从 SSD 迁移到 HDD

这是最经典的应用场景。你的 `C:` 盘 (SSD) 空间不足，但某个程序（如游戏、设计软件）在 `C:\Program Files\SomeApp\Cache` 中存储了大量缓存文件。你可以将这些文件移到大容量的 `D:` 盘 (HDD) 而不影响程序运行。

1.  移动文件夹：将 `C:\Program Files\SomeApp\Cache` 整个移动到 `D:\AppStorage\SomeApp\Cache`
2.  创建联接：在原始位置创建一个指向新位置的联接

- 目标目录：`D:\AppStorage\SomeApp\Cache`
- 链接位置：`C:\Program Files\SomeApp\Cache`

Command Prompt

```cmd
mklink /j "C:\Program Files\SomeApp\Cache" "D:\AppStorage\SomeApp\Cache"
```

PowerShell

```powershell
New-Item -ItemType Junction -Path "C:\Program Files\SomeApp\Cache" -Target "D:\AppStorage\SomeApp\Cache"
```

Zsh （调用 `cmd.exe`）

```zsh
# Junction 是 Windows 特有功能，ln 不支持。最好的方法是直接调用 cmd.exe
cmd.exe /c mklink /j "C:\\Program Files\\SomeApp\\Cache" "D:\\AppStorage\\SomeApp\\Cache"
```

现在，程序仍然向原来的路径写入数据，但这些数据实际上被无缝地存储到了 `D:` 盘。

## 总结与对比

| 特性          | 符号链接                                                  | 硬链接 (Hard Link)                           | 目录联接 (Junction)                            |
| :------------ | :-------------------------------------------------------- | :------------------------------------------- | :--------------------------------------------- |
| 目标类型      | 文件或目录                                                | 仅文件                                       | 仅目录                                         |
| 目标位置      | 任意本地卷或网络共享                                      | 必须在同一卷                                 | 仅限本地卷                                     |
| 删除链接      | 目标不受影响                                              | 目标不受影响（除非是最后一个链接）           | 目标不受影响                                   |
| 删除目标      | 链接失效，变成“断开的”链接                                | 其他链接仍然有效，数据保留                   | 链接失效，变成“断开的”链接                     |
| `mklink` 命令 | `mklink <L> <T>` （文件）<br>`mklink /d <L> <T>` （目录） | `mklink /h <L> <T>`                          | `mklink /j <L> <T>`                            |
| 最佳用途      | 灵活性最高。跨盘、跨网络、同步云盘、管理开发环境。        | 节省空间。为同一文件在同卷内创建多个访问点。 | 兼容性好。无缝迁移本地应用数据，对旧程序友好。 |
