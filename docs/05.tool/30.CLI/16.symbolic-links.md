---
date: 2025-07-08 08:32:31
title: 精通 Windows mklink
permalink: /pages/4165d4
categories:
  - Tool
  - CLI
---

# 精通 Windows `mklink`：符号链接、硬链接和目录联接

在 Windows 系统中，文件和文件夹的管理远不止复制和粘贴。NTFS 文件系统提供了一套强大的工具，称为“链接”，允许你创建高级快捷方式和目录指针，而无需重复存储数据。这不仅能帮你更好地组织文件、节省磁盘空间，还能极大地简化开发和工作流程。

本文将以 `mklink` 命令为核心，深入探讨其三种链接方式：符号链接（Symbolic Links）、硬链接（Hard Links）和目录联接（Junctions）。

<!-- more -->

```cmd
C:\Users\Lenovo>mklink
创建符号链接。

MKLINK [[/D] | [/H] | [/J]] Link Target

        /D      创建目录符号链接。默认为文件
                符号链接。
        /H      创建硬链接而非符号链接。
        /J      创建目录联接。
        Link    指定新的符号链接名称。
        Target  指定新链接引用的路径
                (相对或绝对)。
```

## 1. 符号链接 (Symbolic Link) - 最灵活的链接

符号链接（Symlink）是最通用和最强大的链接类型。它像一个高级快捷方式，是一个包含指向另一个文件或目录路径的小文件。当你访问这个链接时，操作系统会自动将你重定向到目标位置。

创建符号链接通常需要管理员权限的命令提示符或 PowerShell。

### 文件符号链接 (`mklink Link Target`)

这是 `mklink` 的默认模式，用于为单个文件创建链接。

#### 使用场景

**场景一：集中管理配置文件**

假设你希望在所有项目中都使用位于用户目录下的同一个 `.gitconfig` 文件，以保持 Git 配置的一致性。

- **目标文件:** `C:\Users\YourUser\.gitconfig`
- **链接位置:** `D:\Work\ProjectA\.gitconfig`

**Command Prompt (`mklink`)**

```cmd
mklink D:\Work\ProjectA\.gitconfig C:\Users\YourUser\.gitconfig
```

**PowerShell (`New-Item`)**

```powershell
New-Item -ItemType SymbolicLink -Path "D:\Work\ProjectA\.gitconfig" -Target "C:\Users\YourUser\.gitconfig"
```

**Zsh (`ln -s`)**

```zsh
# 注意 Zsh (Git Bash) 中路径的格式和参数顺序
ln -s /c/Users/YourUser/.gitconfig /d/Work/ProjectA/.gitconfig
```

现在，在 `ProjectA` 中执行的 Git 命令会读取 `C:` 盘的全局配置，实现了配置的统一管理。

注意，创建符号链接时，只需手动创建 `目标文件` 即可，无需手动创建 `链接位置`。也就是说，下例中 `-Path` 后面的 `链接位置` 必须事先不存在，不能提前手动创建，否则报错。

例一：

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Users\Lenovo\AppData\Local\nvim-josean" -Target "C:\Users\Lenovo\.config\nvim-josean"
```

例二：

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Users\Lenovo\OneDrive\python_work" -Target "D:\python_work"
```

**场景二：在不同位置运行同一个脚本**

你编写了一个常用的脚本（例如 `build.bat`），并将其保存在一个中央位置（如 `D:\Scripts`）。你希望在多个项目的根目录中都能直接调用这个脚本，而无需复制多份。

- **目标文件:** `D:\Scripts\build.bat`
- **链接位置:** `C:\Projects\ProjectA\build.bat`

**Command Prompt (`mklink`)**

```cmd
mklink C:\Projects\ProjectA\build.bat D:\Scripts\build.bat
```

**PowerShell (`New-Item`)**

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Projects\ProjectA\build.bat" -Target "D:\Scripts\build.bat"
```

**Zsh (`ln -s`)**

```zsh
ln -s /d/Scripts/build.bat /c/Projects/ProjectA/build.bat
```

这样，你只需要维护 `D:\Scripts\build.bat` 这一个文件。在 `ProjectA` 目录中运行 `build.bat`，实际上就是在执行中央脚本，确保了所有项目使用的都是最新版本。

#### 链接名称可以和目标名称不同吗？

当然可以。`mklink` 命令的 `Link` 和 `Target` 参数是完全独立的。`Link` 指定的是你想要创建的链接的完整路径（包含新文件名），而 `Target` 是现有源文件的完整路径。这为你提供了更大的灵活性。

**场景三：为脚本创建更简洁的别名**

假设你的中央脚本有一个很长或不方便记忆的名称，比如 `D:\Shared\Scripts\execute-data-processing-v2.bat`。你可以在项目目录中为其创建一个更短、更易于调用的名称。

- **目标文件:** `D:\Shared\Scripts\execute-data-processing-v2.bat`
- **链接位置和名称:** `C:\Projects\DataAnalysis\run.bat`

**Command Prompt (`mklink`)**

```cmd
mklink C:\Projects\DataAnalysis\run.bat D:\Shared\Scripts\execute-data-processing-v2.bat
```

**PowerShell (`New-Item`)**

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Projects\DataAnalysis\run.bat" -Target "D:\Shared\Scripts\execute-data-processing-v2.bat"
```

**Zsh (`ln -s`)**

```zsh
ln -s /d/Shared/Scripts/execute-data-processing-v2.bat /c/Projects/DataAnalysis/run.bat
```

现在，你只需在 `DataAnalysis` 目录中运行 `run.bat`，就可以执行那个名称很长的脚本，大大提高了便利性。

#### Git 如何处理符号链接？

**问：** 如果目标文件和符号链接本身都由 Git 跟踪，当目标文件的内容被修改时，Git 会检测到链接文件的变化吗？

**答：** 不会。这是一个非常关键且容易混淆的点。Git 对待符号链接有其特殊的方式：

1.  **Git 跟踪的是“路径”，而非“内容”**：当你在 Git 仓库中创建一个符号链接时，Git 并不关心目标文件的内容。它只记录这个链接是一个“符号链接”以及它指向的路径（例如 `../scripts/my-script.js`）。
2.  **目标内容更新，链接本身不变**：如果你修改了目标文件的 _内容_，符号链接文件本身没有发生任何变化——它仍然指向同一个路径。因此，运行 `git status` 时，你会看到目标文件有待提交的更改，但符号链接文件不会显示任何变化。
3.  **必须直接提交目标文件**：这意味着，如果你希望将目标文件的更新纳入版本控制，你必须 `git add` 并 `commit` 目标文件本身，而不是链接。

这个特性使得符号链接在 Git 仓库中非常有用，因为它允许你在不复制文件的情况下，在仓库的不同位置引用同一个文件，同时版本历史也只由目标文件自身维护。

**问：** 那么，当目标文件在它自己的 Git 仓库中被更新并提交后，链接文件仓库中的链接会自动“更新”吗？这是否意味着链接文件仓库永远不会跟踪目标内容的变更？

**答：** 您的理解完全正确。这正是符号链接在版本控制中的核心工作模式。

- **链接文件是“只读”的引用**：从 Git 的角度来看，链接文件仓库中的符号链接只是一个静态的指针。当目标文件的内容在别处（例如，在它自己的 Git 仓库中）被更新时，链接文件本身（那个指针）没有变化，因此在链接文件仓库中运行 `git status` 不会显示任何更改。
- **更新是自动且透明的，但与 Git 无关**：当你 `git pull` 更新了目标文件后，任何通过符号链接访问该文件的操作都会立即读取到最新的内容。这种“更新”是由操作系统在访问时实时完成的，而不是由 Git 在链接文件仓库中执行的。
- **内容历史完全分离**：最终结果是，**链接文件所在的仓库永远不会跟踪目标文件的内容历史**。它只跟踪链接本身是否存在，以及它指向的路径是否发生了变化。所有内容的版本历史都由目标文件所在的仓库独立管理。

这种关注点分离的模式非常强大。它允许一个项目（链接仓库）“借用”另一个项目（目标仓库）的文件，而无需复制文件内容或其复杂的版本历史。

### 目录符号链接 (`mklink /d Link Target`)

使用 `/d` 参数可以为整个目录创建链接。这是符号链接最强大的功能之一，因为它支持跨卷（从 `C:` 到 `D:`）甚至指向网络共享路径。

#### 使用场景

**场景一：将网络驱动器映射为本地文件夹**

某些旧版软件或开发工具可能无法很好地处理网络路径 (`\\Server\Share`)。你可以创建一个目录符号链接，让网络资源看起来就像在本地一样。

- **目标网络路径:** `\\NAS-Server\VideoAssets\ProjectX`
- **链接位置:** `C:\Projects\Current\Assets`

**Command Prompt (`mklink /d`)**

```cmd
mklink /d C:\Projects\Current\Assets \\NAS-Server\VideoAssets\ProjectX
```

**PowerShell (`New-Item`)**

```powershell
New-Item -ItemType SymbolicLink -Path "C:\Projects\Current\Assets" -Target "\\NAS-Server\VideoAssets\ProjectX"
```

**Zsh (`ln -s`)**

```zsh
# Zsh/Bash 中，网络路径通常需要用双斜杠开头
ln -s //NAS-Server/VideoAssets/ProjectX /c/Projects/Current/Assets
```

现在，你可以通过 `C:\Projects\Current\Assets` 访问服务器上的文件，解决了兼容性问题。

**场景二：简化复杂的开发环境**

在一个大型项目中，你可能需要引用一个位于文件系统深处的共享库。通过符号链接，可以将其“拉”到你的项目根目录，方便访问。

- **目标共享库:** `D:\Libs\Common\Core-UI-Components`
- **链接位置:** `D:\Development\WebApp\src\components`

**Command Prompt (`mklink /d`)**

```cmd
mklink /d D:\Development\WebApp\src\components D:\Libs\Common\Core-UI-Components
```

**PowerShell (`New-Item`)**

```powershell
New-Item -ItemType SymbolicLink -Path "D:\Development\WebApp\src\components" -Target "D:\Libs\Common\Core-UI-Components"
```

**Zsh (`ln -s`)**

```zsh
ln -s /d/Libs/Common/Core-UI-Components /d/Development/WebApp/src/components
```

这使得项目结构更清晰，且所有引用此库的项目都能自动获得更新。

## 2. 硬链接 (Hard Link) - 同一文件的多个“入口”

硬链接 (`/h`) 是指向磁盘上完全相同数据块的多个文件入口。它不像快捷方式，而是为同一个文件起了多个名字。所有硬链接地位平等，没有“原始”文件和“快捷方式”之分。只有当指向文件数据的最后一个硬链接被删除时，数据才会被真正删除。

**核心限制:**

- **只能用于文件**，不能用于目录。
- **必须在同一卷上** (例如，链接和目标都必须在 `C:` 盘)。

#### 使用场景

**场景：在不同项目中共享同一个大文件**

假设两个项目需要使用同一个大型资源文件（如模型、数据集或日志文件），但你不想占用双倍的磁盘空间。

- **原始文件:** `C:\Projects\ProjectA\data\large_asset.dat`
- **链接位置:** `C:\Projects\ProjectB\assets\shared_asset.dat`

**Command Prompt (`mklink /h`)**

```cmd
mklink /h C:\Projects\ProjectB\assets\shared_asset.dat C:\Projects\ProjectA\data\large_asset.dat
```

**PowerShell (`New-Item`)**

```powershell
New-Item -ItemType HardLink -Path "C:\Projects\ProjectB\assets\shared_asset.dat" -Target "C:\Projects\ProjectA\data\large_asset.dat"
```

**Zsh (`ln`)**

```zsh
# 创建硬链接时，不使用 -s 参数
ln /c/Projects/ProjectA/data/large_asset.dat /c/Projects/ProjectB/assets/shared_asset.dat
```

现在，`ProjectA` 和 `ProjectB` 共享同一个文件数据。在一个地方修改文件，另一个地方会立即看到变化，且总共只占用一份磁盘空间。

## 3. 目录联接 (Junction Point) - 专为目录重定向而生

目录联接 (`/j`) 是一种专门用于重定向目录的旧版链接。它在功能上与目录符号链接非常相似，但兼容性更好，因为它的工作方式对许多应用程序是完全透明的。

**核心限制:**

- **只能用于目录**。
- **只能指向本地卷上的目录**，不支持网络路径。

- `mklink /J "%UserProfile%\OneDrive\Fonts" "D:\Fonts"`
  为 C:\Users\Lenovo\OneDrive\Fonts <<===>> D:\Fonts 创建的联接

- `mklink /J "%UserProfile%\OneDrive\Ebooks" "D:\Ebooks"`
  为 C:\Users\Lenovo\OneDrive\Ebooks <<===>> D:\Ebooks 创建的联接

#### 使用场景

**场景：将应用程序数据从 SSD 迁移到 HDD**

这是最经典的应用场景。你的 `C:` 盘 (SSD) 空间不足，但某个程序（如游戏、设计软件）在 `C:\Program Files\SomeApp\Cache` 中存储了大量缓存文件。你可以将这些文件移到大容量的 `D:` 盘 (HDD) 而不影响程序运行。

1.  **移动文件夹:** 将 `C:\Program Files\SomeApp\Cache` 整个移动到 `D:\AppStorage\SomeApp\Cache`。
2.  **创建联接:** 在原始位置创建一个指向新位置的联接。

- **目标目录:** `D:\AppStorage\SomeApp\Cache`
- **链接位置:** `C:\Program Files\SomeApp\Cache`

**Command Prompt (`mklink /j`)**

```cmd
mklink /j "C:\Program Files\SomeApp\Cache" "D:\AppStorage\SomeApp\Cache"
```

**PowerShell (`New-Item`)**

```powershell
New-Item -ItemType Junction -Path "C:\Program Files\SomeApp\Cache" -Target "D:\AppStorage\SomeApp\Cache"
```

**Zsh (调用 `cmd.exe`)**

```zsh
# Junction 是 Windows 特有功能，ln 不支持。最好的方法是直接调用 cmd.exe
cmd.exe /c mklink /j "C:\\Program Files\\SomeApp\\Cache" "D:\\AppStorage\\SomeApp\\Cache"
```

现在，程序仍然向原来的路径写入数据，但这些数据实际上被无缝地存储到了 `D:` 盘。

## 总结与对比

| 特性              | 符号链接 (Symbolic Link)                               | 硬链接 (Hard Link)                               | 目录联接 (Junction)                                |
| :---------------- | :----------------------------------------------------- | :----------------------------------------------- | :------------------------------------------------- |
| **目标类型**      | 文件或目录                                             | 仅文件                                           | 仅目录                                             |
| **目标位置**      | 任意本地卷或网络共享                                   | 必须在同一卷                                     | 仅限本地卷                                         |
| **删除链接**      | 目标不受影响                                           | 目标不受影响（除非是最后一个链接）               | 目标不受影响                                       |
| **删除目标**      | 链接失效，变成“断开的”链接                             | 其他链接仍然有效，数据保留                       | 链接失效，变成“断开的”链接                         |
| **`mklink` 命令** | `mklink <L> <T>` (文件)<br>`mklink /d <L> <T>` (目录)  | `mklink /h <L> <T>`                              | `mklink /j <L> <T>`                                |
| **最佳用途**      | **灵活性最高**。跨盘、跨网络、同步云盘、管理开发环境。 | **节省空间**。为同一文件在同卷内创建多个访问点。 | **兼容性好**。无缝迁移本地应用数据，对旧程序友好。 |
